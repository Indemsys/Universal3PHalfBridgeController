// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 2015.11.03
// 11:20:39
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include   "App.h"



/*-----------------------------------------------------------------------------------------------------
  »змер€ем длительность интервала времени ti заданного в милисекундах
-----------------------------------------------------------------------------------------------------*/
uint32_t Measure_reference_time_interval(uint32_t ti)
{
  MQX_TICK_STRUCT tickt_prev;
  MQX_TICK_STRUCT tickt;
  bool            overfl;

  _time_get_ticks(&tickt_prev);
  DELAY_ms(ti);
  _time_get_ticks(&tickt);

  return _time_diff_microseconds(&tickt, &tickt_prev, &overfl);
}


/*-------------------------------------------------------------------------------------------------------------
  ‘онова€ задача.
  »змер€ет загруженность процессора

-------------------------------------------------------------------------------------------------------------*/
void Task_background(unsigned int initial_data)
{
  uint32_t t, dt;

  for (;;)
  {
    t = Measure_reference_time_interval(REF_TIME_INTERVAL);

    if (t < ref_time)
    {
      dt = 0;
    }
    else
    {
      dt = t - ref_time;
    }
    cpu_usage = (1000ul * dt) / ref_time;
  }

}


/*-----------------------------------------------------------------------------------------------------
  ѕолучаем  оценку калибровочного интервала времени предназначенного дл€ измерени€ загрузки процессора

  ѕроводим несколько измерений и выбираем минимальный интервал
-----------------------------------------------------------------------------------------------------*/
void Get_reference_time(void)
{
  uint32_t i;
  uint32_t t,
    tt = 0xFFFFFFFF;

  for (i = 0; i < 10; i++)
  {
    t = Measure_reference_time_interval(REF_TIME_INTERVAL);
    if (t < tt) tt = t;
  }
  ref_time = tt;
}


/*-------------------------------------------------------------------------------------------------------------
  ”становки и инициализаци€ обычной процедуры прерывани€ RTOS
 
  pri - значение приоритета. „ем меньше значение тем выше приоритет.
 
  »нициализируемые здесь прерывани€ вызываютс€ через механизм RTOS
  поэтому значение приоритета должно быть строго в рамках от MQX_HARDWARE_INTERRUPT_LEVEL_MAX до 7 включительно.
 
  ѕопытка установить приоритету меньшее значение приведет к зависанию RTOS!!!
-------------------------------------------------------------------------------------------------------------*/
void Install_and_enable_isr(int num, int pri, INT_ISR_FPTR isr_ptr)
{
  _int_install_isr(num, isr_ptr, 0);
  _bsp_int_init(num, pri, 0, TRUE);
}

/*-------------------------------------------------------------------------------------------------------------
  ”становки и инициализаци€ процедуры прерывани€ €дра RTOS
 
  pri - значение приоритета. „ем меньше значение тем выше приоритет.
 
  »нициализируемые здесь прерывани€ вызываютс€  без использовани€ механизмов RTOS
  поэтому значение приоритета от 0 до 7 включительно.
 
  ”становка приоритета равного или больше MQX_HARDWARE_INTERRUPT_LEVEL_MAX приведет к тому чтопрерывание может блокироватьс€ задачами RTOS
-------------------------------------------------------------------------------------------------------------*/
void Install_and_enable_kernel_isr(int num, int pri, INT_KERNEL_ISR_FPTR isr_ptr)
{
  _int_install_kernel_isr(num, isr_ptr);
  _bsp_int_init(num, pri, 0, TRUE);
}

/*-----------------------------------------------------------------------------------------------------
  «аписать значение защищенной знаковой переменной
-----------------------------------------------------------------------------------------------------*/
void Set_shar_s32val(int32_t *adr, int32_t v)
{
  _int_disable();
  *adr = v;
  _int_enable();
}

/*-----------------------------------------------------------------------------------------------------
  «аписать значение защищенной беззнаковой переменной
-----------------------------------------------------------------------------------------------------*/
void Set_shar_u32val(uint32_t *adr, uint32_t v)
{
  _int_disable();
  *adr = v;
  _int_enable();
}

/*-----------------------------------------------------------------------------------------------------
  «аписать значение защищенной области данных
-----------------------------------------------------------------------------------------------------*/
void Set_shar_buff(void *dest, void *src, uint32_t sz)
{
  _int_disable();
  memcpy(dest, src, sz);
  _int_enable();
}

/*-----------------------------------------------------------------------------------------------------
  ѕолучить значение защищенной беззнаковой переменной
-----------------------------------------------------------------------------------------------------*/
uint32_t Get_shar_u32val(uint32_t *adr)
{
  uint32_t v;
  _int_disable();
  v = *adr;
  _int_enable();
  return v;
}

/*-----------------------------------------------------------------------------------------------------
  ѕолучить значение защищенной знаковой переменной
-----------------------------------------------------------------------------------------------------*/
int32_t Get_shar_s32val(int32_t *adr)
{
  int32_t v;
  _int_disable();
  v = *adr;
  _int_enable();
  return v;
}

/*------------------------------------------------------------------------------

 ------------------------------------------------------------------------------*/
uint32_t Time_elapsed_ms(TIME_STRUCT *tlast_ptr)
{
  TIME_STRUCT tdiff;
  TIME_STRUCT tnow_ptr;
  _time_get(&tnow_ptr);
  _time_diff(tlast_ptr, &tnow_ptr, &tdiff);
  return (tdiff.SECONDS * 1000 + tdiff.MILLISECONDS);
}
/*------------------------------------------------------------------------------

 ------------------------------------------------------------------------------*/
uint32_t Time_elapsed_sec(TIME_STRUCT *tlast_ptr)
{
  TIME_STRUCT tdiff;
  TIME_STRUCT tnow;
  _time_get(&tnow);
  _time_diff(tlast_ptr, &tnow, &tdiff);
  return tdiff.SECONDS;
}

/*------------------------------------------------------------------------------

 ------------------------------------------------------------------------------*/
uint32_t Time_diff_ms(TIME_STRUCT *tlast_ptr, TIME_STRUCT *tnow_ptr)
{
  TIME_STRUCT tdiff;
  _time_diff(tlast_ptr, tnow_ptr, &tdiff);
  return (tdiff.SECONDS * 1000 + tdiff.MILLISECONDS);
}

/*------------------------------------------------------------------------------

 ------------------------------------------------------------------------------*/
uint32_t Time_diff_sec(TIME_STRUCT *tlast_ptr, TIME_STRUCT *current_time)
{
  TIME_STRUCT tdiff;
  _time_diff(tlast_ptr, current_time, &tdiff);
  return tdiff.SECONDS;
}


/*------------------------------------------------------------------------------
  онвертаци€ времени выраженного в мс в тики RTOS
  оличество тиков не может быть меньше 1 с

 \param ms

 \return uint32_t
 ------------------------------------------------------------------------------*/
uint32_t Conv_ms_to_ticks(uint32_t ms)
{
  uint32_t ticks;
  ticks = (_time_get_ticks_per_sec()* ms)/1000;
  if (ticks == 0)
  {
    ticks = 1;
  }
  return ticks;
}

/*------------------------------------------------------------------------------
 —брос системы
 ------------------------------------------------------------------------------*/
void Reset_system(void)
{
  _int_disable();
  // System Control Block -> Application Interrupt and Reset Control Register
  SCB_AIRCR = 0x05FA0000 // ќб€зательный шаблон при записи в этот регистр
              | BIT(2);  // ”становка бита SYSRESETREQ
  for (;;)
  {
    __no_operation();
  }
}


